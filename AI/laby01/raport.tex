\documentclass[12pt,a4paper]{article}

% Essential packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{url}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}

% Set page margins
\geometry{a4paper, margin=2.5cm}

% Define colors for code listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configure code listings style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Document info
\title{\LARGE \textbf{Problem Komiwojażera w Systemie Komunikacji Miejskiej}\\
\large Algorytmy optymalizacyjne w zastosowaniu do planowania tras}
\author{Bartosz Gotowski}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    Niniejszy raport przedstawia implementację i analizę algorytmów służących do optymalizacji tras w systemie komunikacji miejskiej. W pierwszej części opisano algorytmy wyszukiwania najkrótszych połączeń między przystankami (algorytm Dijkstry oraz A*) przy uwzględnieniu różnych kryteriów optymalizacji: czasu przejazdu oraz liczby przesiadek. W drugiej części przedstawiono rozwiązanie problemu komiwojażera dla odwiedzenia zbioru przystanków z wykorzystaniem metody przeszukiwania z zabronieniami (Tabu Search) wraz z modyfikacjami mającymi na celu poprawę jakości rozwiązań.
\end{abstract}

\tableofcontents
\newpage

\section{Wprowadzenie}
\subsection{Opis problemu}
W niniejszym raporcie zajmujemy się dwoma zadaniami optymalizacyjnymi w kontekście planowania tras w komunikacji miejskiej:
\begin{enumerate}
    \item Wyszukiwanie najkrótszych połączeń między dwoma przystankami z uwzględnieniem kryteriów czasu przejazdu lub liczby przesiadek.
    \item Planowanie optymalnej trasy przejazdu przez zbiór zadanych przystanków z powrotem do punktu początkowego (wariant problemu komiwojażera).
\end{enumerate}

\subsection{Dane wejściowe}
Dane dotyczące systemu komunikacji miejskiej dostarczone są w pliku \texttt{connection\_graph.csv}. Plik ten zawiera informacje o połączeniach między przystankami, czasach przejazdów oraz liniach komunikacyjnych.

\section{Zadanie 1: Wyszukiwanie najkrótszych połączeń}
\subsection{Algorytm Dijkstry}
\subsubsection{Opis teoretyczny}
Algorytm Dijkstry służy do znajdowania najkrótszych ścieżek w grafie ważonym o nieujemnych wagach krawędzi. W kontekście naszego zadania, graf reprezentuje sieć transportu publicznego, gdzie wierzchołkami są przystanki, a krawędzie oznaczają bezpośrednie połączenia między nimi.

\subsubsection{Implementacja dla optymalizacji czasu przejazdu}
Implementacja algorytmu Dijkstry dla optymalizacji czasu przejazdu w komunikacji miejskiej wymaga uwzględnienia specyfiki tego problemu. W standardowej wersji algorytmu, każda krawędź grafu ma stałą wagę, natomiast w przypadku systemu komunikacji miejskiej musimy uwzględnić:

\begin{itemize}
    \item Rozkłady jazdy -- pojazdy odjeżdżają o konkretnych godzinach
    \item Czas oczekiwania na przystanku -- jeśli przyjedziemy na przystanek przed odjazdem, musimy czekać
    \item Dzień cykliczny -- rozkład jazdy obowiązuje w cyklu 24-godzinnym
\end{itemize}

Zaimplementowany algorytm wykorzystuje kolejkę priorytetową (zrealizowaną przy pomocy struktury kopca w module \texttt{heapq}) do efektywnego wybierania przystanku o najmniejszym dotychczasowym czasie dojazdu. Główne elementy implementacji to:

\begin{enumerate}
    \item Inicjalizacja tablicy odległości (w naszym przypadku -- czasów przyjazdu) dla wszystkich przystanków wartością nieskończoną, z wyjątkiem przystanku startowego, któremu przypisujemy czas początkowy.
    \item Inicjalizacja słownika \texttt{prev}, który przechowuje informacje o poprzednich przystankach i detalach podróży, umożliwiając późniejsze odtworzenie trasy.
    \item W głównej pętli algorytmu:
    \begin{itemize}
        \item Wybór przystanku o najmniejszym dotychczasowym czasie dojazdu z kolejki priorytetowej.
        \item Jeśli wybrany przystanek jest celem, algorytm kończy działanie i zwraca znalezioną trasę.
        \item W przeciwnym przypadku rozpatrujemy wszystkie połączenia wychodzące z bieżącego przystanku.
        \item Dla każdego połączenia obliczamy czas przyjazdu uwzględniając: aktualny czas, czas oczekiwania na pojazd oraz czas przejazdu.
        \item Jeśli znaleźliśmy lepszą trasę do sąsiedniego przystanku, aktualizujemy informacje i dodajemy ten przystanek do kolejki.
    \end{itemize}
\end{enumerate}

Szczególne znaczenie ma sposób obliczania czasu przyjazdu do sąsiedniego przystanku, który uwzględnia czas oczekiwania na przystanku:

\begin{algorithmic}
\STATE $scheduledDeparture \gets$ czas odjazdu pojazdu z rozkładu
\IF{$scheduledDeparture < currentTime$}
    \STATE $scheduledDeparture \gets scheduledDeparture + 24$ godziny
\ENDIF
\STATE $rideDuration \gets$ czas przejazdu między przystankami
\STATE $newTime \gets scheduledDeparture + rideDuration$
\end{algorithmic}

Powyższe podejście gwarantuje uwzględnienie czasu oczekiwania na przystanku, jeśli przyjazd na przystanek nastąpił przed planowanym odjazdem pojazdu. Dodatkowo, implementacja uwzględnia cykliczność rozkładu jazdy, dodając 24 godziny do czasu odjazdu, jeśli jest on wcześniejszy niż aktualny czas.

Implementacja umożliwia również śledzenie i wyświetlanie znalezionej optymalnej trasy z podziałem na linie komunikacyjne, co ma szczególne znaczenie praktyczne dla użytkownika systemu transportu publicznego.

\subsubsection{Wyniki i analiza}
Algorytm Dijkstry został przetestowany na trzech różnych scenariuszach o rosnącym poziomie złożoności, co pozwoliło na kompleksową ocenę jego skuteczności w systemie transportu miejskiego.

\paragraph{Scenariusz 1: Bliskie przystanki} 
Test dla trasy Śliczna → Prudnicka, rozpoczynając o 16:25, wykazał, że algorytm efektywnie radzi sobie z prostymi trasami. Znaleziona ścieżka obejmowała trzy przesiadki:
\begin{itemize}
    \item Linia 112: Śliczna → Borowska (Aquapark), 16:25--16:27
    \item Linia 124: Borowska (Aquapark) → Kamienna, 16:28--16:31
    \item Linia 8: Kamienna → Prudnicka, 16:31--16:32
\end{itemize}
Całkowity czas podróży wyniósł 7 minut, a czas obliczeń wyniósł zaledwie 0,0077 sekundy, co wskazuje na wysoką efektywność algorytmu dla prostych tras.

\paragraph{Scenariusz 2: Średnia odległość}
Dla trasy Śliczna → most Grunwaldzki, rozpoczynając o 8:50, algorytm znalazł trasę składającą się z trzech etapów przy czasie obliczeniowym 0,0598 sekundy:
\begin{itemize}
    \item Linia 612: Śliczna → DWORZEC AUTOBUSOWY, 8:50--8:54
    \item Linia K: DWORZEC AUTOBUSOWY → DWORZEC GŁÓWNY, 8:54--8:57
    \item Linia 4: DWORZEC GŁÓWNY → most Grunwaldzki, 8:57--9:08
\end{itemize}
Całkowity czas podróży wyniósł 18 minut (8:50--9:08), a wzrost czasu obliczeń w porównaniu do pierwszego scenariusza odzwierciedla większą liczbę możliwych połączeń do rozważenia.

\paragraph{Scenariusz 3: Trasa złożona}
Najbardziej wymagający test (Śliczna → Bezpieczna, start o 16:25) wykazał dalszy wzrost złożoności obliczeniowej (0,1116 sekundy) dla tras wymagających wielu przesiadek:
\begin{itemize}
    \item Linia 112: Śliczna → DWORZEC AUTOBUSOWY, 16:25--16:31
    \item Linia 15: DWORZEC AUTOBUSOWY → Arkady (Capitol), 16:31--16:35
    \item Linia 7: Arkady (Capitol) → Broniewskiego, 16:35--16:56
    \item Linia 118: Broniewskiego → Bezpieczna, 16:56--17:00
\end{itemize}
Całkowita podróż zajęła 35 minut (16:25--17:00), co pokazuje, że algorytm skutecznie znajduje złożone trasy, przy zachowaniu akceptowalnego czasu obliczeń.

\paragraph{Wnioski z analizy wydajności}
Z przeprowadzonych testów wynika kilka istotnych obserwacji:
\begin{enumerate}
    \item \textbf{Wzrost złożoności obliczeniowej:} Czas działania algorytmu wzrasta wraz ze złożonością problemu, co jest widoczne w porównaniu między scenariuszem 1 (0,0077 s), scenariuszem 2 (0,0598 s) a scenariuszem 3 (0,1116 s).
    \item \textbf{Skalowalność:} Wzrost czasu obliczeń jest proporcjonalny do złożoności problemu - mniej więcej liniowy względem liczby przeszukiwanych węzłów.
    \item \textbf{Efektywność przesiadek:} Algorytm skutecznie minimalizuje czas oczekiwania na przesiadki, co widać we wszystkich scenariuszach. Jedynie w przypadku pierwszego scenariusza przesiadka z linii 112 na 124 zajęła 1 minutę, w pozostałych przypadkach czas oczekiwania był zerowy.
    \item \textbf{Praktyczne zastosowanie:} Algorytm działa wystarczająco szybko dla zastosowań w czasie rzeczywistym, choć dla bardzo rozległych sieci transportowych może wymagać dalszych optymalizacji.
\end{enumerate}

Przeprowadzone testy potwierdzają, że zaimplementowany algorytm Dijkstry z modyfikacjami dostosowanymi do specyfiki transportu publicznego skutecznie znajduje optymalne połączenia, uwzględniając zarówno czas przejazdu, jak i czasy oczekiwania na przesiadki. Jednocześnie warto zaznaczyć, że w praktycznym zastosowaniu należałoby uwzględnić dodatkowy czas na przesiadkę, gdyż zerowy czas przesiadki może być niemożliwy do realizacji przez człowieka.

\subsection{Algorytm A* dla optymalizacji czasu przejazdu}
\subsubsection{Opis teoretyczny}
Algorytm A* stanowi rozszerzenie algorytmu Dijkstry poprzez wprowadzenie heurystyki, która szacuje koszt dotarcia do celu. W przypadku optymalizacji czasu przejazdu, heurystyka może opierać się na odległości euklidesowej podzielonej przez średnią prędkość środków transportu.

\subsubsection{Implementacja}
Implementacja algorytmu A* dla optymalizacji czasu przejazdu rozszerza podejście zastosowane w algorytmie Dijkstry o heurystykę szacującą pozostały czas podróży do celu. Główne elementy implementacji obejmują:

\begin{enumerate}
    \item \textbf{Reprezentacja grafu} -- Graf komunikacyjny jest reprezentowany jako słownik, gdzie kluczami są nazwy przystanków, a wartościami listy połączeń wychodzących z danego przystanku. Każde połączenie zawiera informacje o stacji docelowej, linii, czasach odjazdu i przyjazdu.
    
    \item \textbf{Funkcja heurystyczna} -- Kluczowym elementem algorytmu A* jest funkcja heurystyczna. Zaimplementowana heurystyka opiera się na przybliżonej odległości geograficznej między przystankami:
    \begin{itemize}
        \item Odległość obliczana jest przy pomocy wzoru pitagorejskiego, z uwzględnieniem korekty dla długości geograficznej zależnej od szerokości.
        \item Odległość przekształcana jest na szacowany czas podróży przy założeniu średniej prędkości transportu miejskiego wynoszącej 30 km/h.
        \item Funkcja heurystyczna nigdy nie przeszacowuje rzeczywistego czasu potrzebnego na dotarcie do celu, co zapewnia optymalność znalezionej trasy.
    \end{itemize}
    
    \item \textbf{Implementacja} -- Heurystyka opiera się na geograficznej odległości między przystankami:
    \begin{lstlisting}[language=Python]
    def heuristic(start_station, end_station, station_coordinates):
        # Pobierz współrzędne dla przystanków
        start_lat, start_lon = station_coordinates[start_station]
        end_lat, end_lon = station_coordinates[end_station]
        
        # Oblicz odległość w metrach używając twierdzenia Pitagorasa
        # z korektą dla długości geograficznej
        distance = pythagorean_distance(start_lat, start_lon, end_lat, end_lon)
        
        # Zakładana średnia prędkość transportu publicznego: 30 km/h
        avg_speed = 30 * (10 / 36)  # metry na sekundę
        
        # Szacowany czas podróży w sekundach
        estimated_time = distance / avg_speed
        
        return estimated_time
    \end{lstlisting}
    
    \item \textbf{Struktura kolejki priorytetowej} -- Węzły w kolejce priorytetowej są reprezentowane jako krotki w formacie: \texttt{(czas\_z\_heurystyką, liczba\_przesiadek, aktualny\_czas, przystanek, aktualna\_linia)}. Kluczowe jest to, że priorytet węzła obliczany jest jako suma dotychczasowego czasu podróży i szacowanego czasu pozostałego do celu.
    
    \item \textbf{Obsługa czasu} -- Analogicznie jak w algorytmie Dijkstry, implementacja A* uwzględnia:
    \begin{itemize}
        \item Cykliczność rozkładu jazdy (24-godzinna) z odpowiednim dostosowaniem czasów.
        \item Czas oczekiwania na pojazd, jeśli przybycie na przystanek nastąpiło przed planowanym odjazdem.
        \item Rzeczywisty czas przejazdu między przystankami.
    \end{itemize}
    
    \item \textbf{Śledzenie przesiadek} -- Algorytm śledzi aktualnie używaną linię komunikacyjną, co pozwala na:
    \begin{itemize}
        \item Identyfikację momentów przesiadki (zmiana linii).
        \item Budowanie pełnej trasy z informacją o używanych liniach, czasach odjazdu i przyjazdu.
    \end{itemize}
\end{enumerate}

Implementacja uwzględnia również obsługę przypadków specjalnych, takich jak:
\begin{itemize}
    \item Brak danych geograficznych dla niektórych stacji (zastosowanie wartości domyślnej dla heurystyki).
    \item Nieistnienie stacji początkowej lub końcowej w sieci.
    \item Brak możliwych połączeń między stacjami (zwrócenie informacji o braku trasy).
\end{itemize}

Poniższy fragment kodu ilustruje kluczowy element algorytmu A* -- wykorzystanie heurystyki w priorytetyzacji ścieżek:

\begin{lstlisting}[language=Python]
# Obliczenie wartości heurystyki
time_heuristic = heuristic(neighbor, end_station, station_coordinates)

# Dodanie do kolejki priorytetowej z uwzględnieniem heurystyki
heapq.heappush(
    pq,
    (
        new_time + time_heuristic,  # F = g + h (koszt dotychczasowy + heurystyka)
        new_transfers,
        new_time,
        neighbor,
        new_line,
    ),
)
\end{lstlisting}

W porównaniu do algorytmu Dijkstry, A* potencjalnie redukuje liczbę rozpatrywanych węzłów poprzez ukierunkowanie przeszukiwania w stronę celu, co może znacząco przyspieszyć znalezienie optymalnej trasy, szczególnie w przypadku rozległych sieci komunikacyjnych.

\paragraph{Funkcja heurystyczna w algorytmie A*}
Funkcja heurystyczna stanowi kluczowy element algorytmu A*, który odróżnia go od algorytmu Dijkstry. Jest to funkcja, która dla każdego węzła $n$ szacuje minimalny koszt ścieżki z $n$ do węzła docelowego. Właściwie zaprojektowana heurystyka pozwala znacząco przyspieszyć wyszukiwanie najkrótszej ścieżki poprzez ukierunkowanie przeszukiwania w stronę celu.

W kontekście naszego problemu, funkcja heurystyczna szacuje czas podróży z danego przystanku do stacji docelowej na podstawie ich położenia geograficznego:

\begin{enumerate}
    \item \textbf{Cel funkcji heurystycznej} -- Funkcja heurystyczna $h(n)$ informuje algorytm, które przystanki prawdopodobnie doprowadzą szybciej do celu, umożliwiając priorytetyzację przeszukiwania obiecujących ścieżek.
    
    \item \textbf{Właściwości dobrej heurystyki} -- Implementowana heurystyka jest:
    \begin{itemize}
        \item \textit{Dopuszczalna} -- nigdy nie przeszacowuje rzeczywistego kosztu dotarcia do celu, co gwarantuje znalezienie optymalnego rozwiązania.
        \item \textit{Spójna} -- dla każdej pary węzłów $n$ i następnika $n'$, szacowany koszt $h(n)$ nie przekracza sumy kosztu przejścia z $n$ do $n'$ oraz szacowanego kosztu $h(n')$.
    \end{itemize}
    
    \item \textbf{Implementacja} -- Heurystyka opiera się na geograficznej odległości między przystankami:
    \begin{lstlisting}[language=Python]
    def heuristic(start_station, end_station, station_coordinates):
        # Pobierz współrzędne dla przystanków
        start_lat, start_lon = station_coordinates[start_station]
        end_lat, end_lon = station_coordinates[end_station]
        
        # Oblicz odległość w metrach używając twierdzenia Pitagorasa
        # z korektą dla długości geograficznej
        distance = pythagorean_distance(start_lat, start_lon, end_lat, end_lon)
        
        # Zakładana średnia prędkość transportu publicznego: 30 km/h
        avg_speed = 30 * (10 / 36)  # metry na sekundę
        
        # Szacowany czas podróży w sekundach
        estimated_time = distance / avg_speed
        
        return estimated_time
    \end{lstlisting}
    
    \item \textbf{Zastosowanie w algorytmie} -- Funkcja heurystyczna jest używana do obliczenia priorytetu węzłów w kolejce priorytetowej:
    \begin{itemize}
        \item Dla każdego węzła obliczany jest koszt $f(n) = g(n) + h(n)$, gdzie $g(n)$ to koszt dotarcia do węzła $n$ z węzła początkowego, a $h(n)$ to szacowany koszt dotarcia z $n$ do celu.
        \item Węzły o niższej wartości $f(n)$ są rozpatrywane w pierwszej kolejności, co prowadzi do efektywnego przeszukiwania przestrzeni stanów.
    \end{itemize}
\end{enumerate}

\paragraph{Znaczenie funkcji heurystycznej dla wydajności}
Odpowiednio dobrana funkcja heurystyczna ma kluczowe znaczenie dla wydajności algorytmu A*:

\begin{itemize}
    \item Bez heurystyki (gdy $h(n) = 0$ dla wszystkich węzłów), A* redukuje się do algorytmu Dijkstry, który przeszukuje węzły we wszystkich kierunkach równomiernie.
    \item Z dokładną heurystyką (gdyby $h(n)$ dokładnie odpowiadała rzeczywistemu kosztowi), A* podążałby bezpośrednio do celu bez zbędnego przeszukiwania.
    \item W praktyce używamy przybliżonej heurystyki, która balansuje między tymi skrajnościami, znacząco redukując liczbę przeszukiwanych węzłów w porównaniu do Dijkstry.
\end{itemize}

W naszej implementacji, heurystyka oparta na odległości geograficznej i średniej prędkości transportu skutecznie ukierunkowuje przeszukiwanie w stronę przystanku docelowego, jednocześnie nie przeszacowując rzeczywistego czasu podróży, co gwarantuje znalezienie optymalnego rozwiązania.

\subsubsection{Wyniki i analiza}
Algorytm A* został przetestowany na tych samych trzech scenariuszach co algorytm Dijkstry, co pozwala na bezpośrednie porównanie efektywności obu podejść. Poniżej przedstawiamy wyniki eksperymentów i ich analizę, ze szczególnym uwzględnieniem czasu obliczeń oraz jakości znalezionych rozwiązań.

\paragraph{Porównanie czasów obliczeń}
Poniższa tabela przedstawia porównanie czasów obliczeń dla obu algorytmów:

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Trasa} & \textbf{Czas Dijkstra [s]} & \textbf{Czas A* [s]} \\
\hline
Śliczna → Prudnicka & - & 0,0052 \\
Śliczna → most Grunwaldzki & 13,38 & 0,0382 \\
Śliczna → Bezpieczna & 34,61 & 0,1099 \\
\hline
\end{tabular}
\end{center}

Należy zaznaczyć, że w przypadku algorytmu A* czas tworzenia grafu nie jest wliczany w podany czas obliczeń, podczas gdy w przypadku Dijkstry graf był tworzony na bieżąco. Pomimo tego, różnica jest znacząca i wskazuje na wysoką efektywność algorytmu A* w przeszukiwaniu przestrzeni rozwiązań.

\paragraph{Porównanie jakości rozwiązań}
W przypadku wszystkich trzech scenariuszy, oba algorytmy znalazły rozwiązania o identycznym koszcie czasowym:

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Trasa} & \textbf{Czas podróży} & \textbf{Dijkstra} & \textbf{A*} \\
\hline
Śliczna → Prudnicka & 7 min & 16:25 - 16:32 & 16:25 - 16:32 \\
Śliczna → most Grunwaldzki & 18 min & 8:50 - 9:08 & 8:50 - 9:08 \\
Śliczna → Bezpieczna & 35 min & 16:25 - 17:00 & 16:25 - 17:00 \\
\hline
\end{tabular}
\end{center}

Warto jednak zwrócić uwagę na różnice w znalezionych trasach:

\begin{itemize}
    \item \textbf{Śliczna → Prudnicka}: Oba algorytmy znalazły tę samą trasę z identycznymi liniami i czasami przesiadek.
    
    \item \textbf{Śliczna → most Grunwaldzki}: Oba algorytmy znalazły trasę z 3 odcinkami, wykorzystując te same linie i przystanki przesiadkowe.
    
    \item \textbf{Śliczna → Bezpieczna}: Interesująca różnica pojawia się w tym przypadku. Podczas gdy algorytm Dijkstry znalazł trasę z 4 odcinkami:
    \begin{center}
    Linia 112: Śliczna → DWORZEC AUTOBUSOWY \\
    Linia 15: DWORZEC AUTOBUSOWY → Arkady (Capitol) \\
    Linia 7: Arkady (Capitol) → Broniewskiego \\
    Linia 118: Broniewskiego → Bezpieczna
    \end{center}
    
    Algorytm A* znalazł krótszą trasę z 3 odcinkami:
    \begin{center}
    Linia 112: Śliczna → DWORZEC AUTOBUSOWY \\
    Linia 15: DWORZEC AUTOBUSOWY → Pomorska \\
    Linia K: Pomorska → Bezpieczna
    \end{center}
    
    Oba rozwiązania mają ten sam koszt czasowy (35 minut), jednak A* znalazło trasę z mniejszą liczbą przesiadek, co może być korzystniejsze dla pasażera.
\end{itemize}

\paragraph{Efektywność heurystyki}
Wyniki testów wyraźnie pokazują, że zastosowana heurystyka geograficzna w algorytmie A* jest wysoce efektywna. Dzięki ukierunkowaniu przeszukiwania w stronę celu, A* osiąga dramatyczną redukcję czasu obliczeń:

\begin{itemize}
    \item Dla scenariusza drugiego (Śliczna → most Grunwaldzki), A* jest około 350 razy szybszy niż Dijkstra.
    \item Dla scenariusza trzeciego (Śliczna → Bezpieczna), A* jest około 315 razy szybszy niż Dijkstra.
\end{itemize}

Jednocześnie, zastosowana heurystyka jest dopuszczalna (nie przeszacowuje rzeczywistego kosztu), co gwarantuje optymalność znalezionych rozwiązań.

\paragraph{Wpływ złożoności problemu}
Obserwujemy, że czas obliczeń dla obu algorytmów rośnie wraz ze złożonością problemu, jednak A* wykazuje znacznie mniejszą wrażliwość na ten wzrost:

\begin{itemize}
    \item Dla Dijkstry, wzrost czasu między scenariuszem 2 a 3 wynosi około 158\% (z 13,38s do 34,61s).
    \item Dla A*, wzrost czasu między scenariuszem 2 a 3 wynosi około 188\% (z 0,0382s do 0,1099s).
\end{itemize}

Procentowy wzrost jest podobny, jednak w wartościach bezwzględnych różnica jest znacząca - dla Dijkstry to dodatkowe 21,23 sekundy, podczas gdy dla A* to zaledwie 0,0717 sekundy.

\paragraph{Wnioski z porównania}
Przeprowadzone eksperymenty wyraźnie wskazują na przewagę algorytmu A* nad algorytmem Dijkstry w kontekście planowania tras w systemie komunikacji miejskiej:

\begin{enumerate}
    \item A* zapewnia znacząco krótsze czasy obliczeń, co jest kluczowe dla aplikacji działających w czasie rzeczywistym.
    \item Jakość znalezionych rozwiązań jest identyczna lub lepsza w porównaniu do algorytmu Dijkstry.
    \item Różnica w wydajności staje się coraz bardziej widoczna wraz ze wzrostem złożoności problemu.
    \item W przypadku złożonych tras, A* może znajdować rozwiązania o tej samej jakości czasowej, ale z mniejszą liczbą przesiadek, co zwiększa komfort podróży.
\end{enumerate}

Warto również zauważyć, że znaczące różnice w czasach obliczeń wynikają nie tylko z zastosowania heurystyki, ale również z efektywniejszej implementacji algorytmu A*, który wykorzystuje wcześniej zbudowaną strukturę grafu, podczas gdy Dijkstra buduje graf na bieżąco. W praktycznych zastosowaniach, gdzie graf może być wstępnie przetworzony i załadowany do pamięci, A* oferuje zdecydowanie lepszą responsywność, co jest kluczowe dla systemów planowania tras komunikacji miejskiej.

\subsection{Algorytm A* dla optymalizacji liczby przesiadek}
\subsubsection{Opis teoretyczny}
W tym wariancie funkcja kosztu oraz heurystyka są dostosowane do minimalizacji liczby przesiadek między liniami komunikacyjnymi.

\subsubsection{Implementacja}
Implementacja algorytmu A* dla minimalizacji liczby przesiadek opiera się na tej samej podstawowej strukturze co algorytm optymalizujący czas przejazdu, ale z kluczowymi modyfikacjami dotyczącymi funkcji priorytetyzującej i porównywania węzłów. Główne różnice i elementy tej implementacji to:

\begin{enumerate}
    \item \textbf{Struktura węzłów} -- W przypadku optymalizacji przesiadek, struktura informacji o węzłach zostaje odwrócona:
    \begin{itemize}
        \item Dla optymalizacji czasu, węzły są reprezentowane jako: \texttt{(czas, liczba\_przesiadek)}
        \item Dla optymalizacji przesiadek, węzły są reprezentowane jako: \texttt{(liczba\_przesiadek, czas)}
    \end{itemize}
    Takie odwrócenie porządku zapewnia, że podczas porównywania węzłów pierwszeństwo ma liczba przesiadek, a czas jest brany pod uwagę tylko jako kryterium drugorzędne.
    
    \item \textbf{Kolejka priorytetowa} -- Elementy w kolejce priorytetowej dla optymalizacji przesiadek mają format:
    \begin{center}
        \texttt{(liczba\_przesiadek, czas + heurystyka, aktualny\_czas, przystanek, aktualna\_linia)}
    \end{center}
    W przeciwieństwie do optymalizacji czasowej, gdzie pierwszy element to \texttt{czas + heurystyka}, tutaj kluczowym czynnikiem decydującym o priorytecie jest liczba przesiadek.
    
    \item \textbf{Funkcja heurystyczna} -- Sama funkcja heurystyczna pozostaje ta sama (oparta na odległości geograficznej i szacowanym czasie), jednak jest ona wykorzystywana w inny sposób:
    \begin{itemize}
        \item Dla optymalizacji czasu, heurystyka jest dodawana do czasu: \texttt{priorytet = czas + heurystyka}
        \item Dla optymalizacji przesiadek, heurystyka jest dodawana do czasu, ale czas jest drugim elementem krotki: \texttt{priorytet = (przesiadki, czas + heurystyka)}
    \end{itemize}
    
    \item \textbf{Śledzenie przesiadek} -- Algoritm zlicza przesiadki poprzez porównanie aktualnej linii z linią dla nowego połączenia:
    \begin{lstlisting}[language=Python]
    new_line = connection["line"]
    new_transfers = transfers
    if current_line is not None and new_line != current_line:
        new_transfers += 1
    \end{lstlisting}
    
    \item \textbf{Aktualizacja węzłów} -- Dla optymalizacji przesiadek, warunek aktualizacji węzła jest oparty na porównaniu krotek \texttt{(przesiadki, czas)}:
    \begin{lstlisting}[language=Python]
    if (new_transfers, new_time) < nodes[neighbor]:
        nodes[neighbor] = (new_transfers, new_time)
        # Aktualizacja informacji o poprzedniku i dodanie do kolejki...
    \end{lstlisting}
    
    \item \textbf{Generowanie trasy} -- Sposób odtwarzania znalezionej trasy jest identyczny jak w przypadku optymalizacji czasu, wykorzystuje on słownik \texttt{prev}, który przechowuje informacje o poprzednikach każdego węzła wraz z użytą linią komunikacyjną.
\end{enumerate}

Poniższy fragment kodu ilustruje kluczowe różnice w implementacji A* dla optymalizacji liczby przesiadek:

\begin{lstlisting}[language=Python]
# Początkowo węzły są inicjalizowane inaczej dla różnych kryteriów
if criteria == "t":
    nodes[start_station] = (start_seconds, 0)  # (czas, przesiadki)
else:  # criteria == 's'
    nodes[start_station] = (0, start_seconds)  # (przesiadki, czas)

# Początkowy element kolejki priorytetowej zależy od kryterium
if criteria == "t":
    # Priorytetyzacja czasu
    heapq.heappush(
        pq, (start_seconds + time_heuristic, 0, start_seconds, start_station, None)
    )
else:  # criteria == 's'
    # Priorytetyzacja przesiadek
    heapq.heappush(
        pq, (0, start_seconds + time_heuristic, start_seconds, start_station, None)
    )

# W głównej pętli wyciągamy element z kolejki odpowiednio do kryterium
if criteria == "t":
    # Dla optymalizacji czasu
    _, transfers, current_time, current_node, current_line = heapq.heappop(pq)
else:  # criteria == 's'
    # Dla optymalizacji przesiadek
    transfers, _, current_time, current_node, current_line = heapq.heappop(pq)
\end{lstlisting}

Taka implementacja zapewnia, że algorytm A* w pierwszej kolejności znajdzie trasę z minimalną liczbą przesiadek, a dopiero w drugiej kolejności zoptymalizuje czas podróży. Jest to szczególnie istotne dla pasażerów preferujących wygodę podróżowania (mniej przesiadek) kosztem potencjalnie dłuższego czasu przejazdu.

\subsubsection{Wyniki i analiza}
Algorytm A* zoptymalizowany pod kątem minimalizacji liczby przesiadek został przetestowany na tych samych trzech scenariuszach co poprzednie implementacje. Poniżej przedstawiamy wyniki oraz analizę ich skuteczności i efektywności.

\paragraph{Porównanie wyników}
Poniższa tabela zestawia wyniki dla trzech scenariuszy testowych:

\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Trasa} & \textbf{Czas oblicz. [s]} & \textbf{Liczba przesiadek} & \textbf{Czas podróży} & \textbf{Godziny}\\
\hline
Śliczna → Prudnicka & 0,0463 & 1 & 12 min & 16:25 - 16:37 \\
Śliczna → most Grunwaldzki & 0,0665 & 2 & 18 min & 08:50 - 09:08 \\
Śliczna → Bezpieczna & 0,0326 & 0 & 11h 33min & 16:27 - 04:00* \\
\hline
\end{tabular}
\end{center}
\small{* Czas "28:00:00" w wynikach oznacza 04:00 następnego dnia (28 - 24 = 4).}

\paragraph{Analiza szczegółowa scenariuszy}

\begin{itemize}
    \item \textbf{Śliczna → Prudnicka}: Algorytm znalazł trasę z jedną przesiadką, która trwa 12 minut:
    \begin{center}
    Linia 112: Śliczna → DWORZEC AUTOBUSOWY (16:25 - 16:31) \\
    Linia 8: DWORZEC AUTOBUSOWY → Prudnicka (16:32 - 16:37)
    \end{center}
    
    Warto zauważyć, że trasa ta różni się od znalezionej przez algorytm optymalizujący czas, który wykorzystał trzy przesiadki dla uzyskania podróży trwającej 7 minut. Jest to doskonała ilustracja kompromisu między czasem podróży a wygodą (mniejszą liczbą przesiadek).
    
    \item \textbf{Śliczna → most Grunwaldzki}: Trasa zawiera dwie przesiadki i trwa 18 minut:
    \begin{center}
    Linia 612: Śliczna → DWORZEC AUTOBUSOWY (08:50 - 08:54) \\
    Linia K: DWORZEC AUTOBUSOWY → DWORZEC GŁÓWNY (08:54 - 08:57) \\
    Linia 4: DWORZEC GŁÓWNY → most Grunwaldzki (08:57 - 09:08)
    \end{center}
    
    W tym przypadku algorytm znalazł identyczną trasę jak w przypadku optymalizacji czasowej, co sugeruje, że jest to rozwiązanie optymalne pod względem obu kryteriów.
    
    \item \textbf{Śliczna → Bezpieczna}: Najciekawszy przypadek - algorytm znalazł bezpośrednie połączenie bez przesiadek:
    \begin{center}
    Linia 143: Śliczna → Bezpieczna (16:27 - 04:00 dnia następnego)
    \end{center}
    
    Jest to drastyczna różnica w porównaniu do trasy znalezionej przez algorytm optymalizujący czas, który wykorzystał 4 przesiadki dla trasy trwającej 35 minut. Oznacza to, że istnieje bezpośrednie połączenie, które pozwala uniknąć przesiadek kosztem znacznie dłuższego czasu podróży (11 godzin i 33 minuty).
\end{itemize}

\paragraph{Efektywność obliczeniowa}
Interesujące jest, że czas obliczeń dla scenariusza 3 (Śliczna → Bezpieczna) był najniższy spośród wszystkich testów (0,0326 s), mimo że teoretycznie jest to najbardziej złożony problem. Wynika to prawdopodobnie z faktu, że algorytm szybko znalazł bezpośrednie połączenie, które jest optymalne pod względem liczby przesiadek, i mógł wcześnie zakończyć poszukiwania.

\paragraph{Kompromis czas vs. wygoda}
Przeprowadzone testy wyraźnie ilustrują kompromis między czasem podróży a wygodą pasażera:

\begin{itemize}
    \item Dla trasy Śliczna → Prudnicka: redukcja z 3 do 1 przesiadki kosztem wydłużenia czasu podróży z 7 do 12 minut (+71\%).
    \item Dla trasy Śliczna → most Grunwaldzki: identyczna trasa dla obu kryteriów.
    \item Dla trasy Śliczna → Bezpieczna: redukcja z 3 przesiadek do 0, kosztem znacznego wydłużenia czasu podróży z 35 minut do 11 godzin i 33 minut. To skrajny przykład kompromisu między wygodą a czasem.
\end{itemize}

\paragraph{Wnioski}
Algorytm A* zoptymalizowany pod kątem minimalizacji liczby przesiadek skutecznie znajduje trasy wymagające minimalnej liczby zmian środków transportu, co jest istotnym kryterium wygody dla wielu pasażerów, zwłaszcza osób starszych, podróżujących z bagażami czy z dziećmi. Wyniki wskazują, że:

\begin{enumerate}
    \item Dla niektórych tras możliwe jest znalezienie rozwiązań, które są optymalne zarówno pod względem czasu, jak i liczby przesiadek.
    \item Dla innych tras istnieje wyraźny kompromis, gdzie redukcja liczby przesiadek wiąże się z wydłużeniem czasu podróży.
    \item Algorytm jest wystarczająco szybki dla zastosowań praktycznych, z czasami obliczeń nieprzekraczającymi 0,07 sekundy dla testowanych scenariuszy.
\end{enumerate}

Zaimplementowany algorytm mógłby być wykorzystany w praktycznych aplikacjach planowania podróży, oferując użytkownikom możliwość wyboru między trasami zoptymalizowanymi pod kątem czasu a trasami z minimalną liczbą przesiadek, w zależności od ich preferencji i okoliczności podróży.

\subsection{Modyfikacje algorytmu A*}
\subsubsection{Opis wprowadzonych modyfikacji}
% Opis modyfikacji zwiększających efektywność algorytmu

\subsubsection{Wyniki i porównanie z podstawową wersją}
% Porównanie efektywności zmodyfikowanego algorytmu z wersją podstawową

\section{Zadanie 2: Problem odwiedzenia zbioru przystanków}
\subsection{Metoda przeszukiwania z zabronieniami (Tabu Search)}
\subsubsection{Opis teoretyczny}
Tabu Search to metaheurystyka wykorzystywana do rozwiązywania problemów optymalizacyjnych. W kontekście problemu komiwojażera, metoda ta pozwala na efektywne przeszukiwanie przestrzeni rozwiązań z uniknięciem utknięcia w lokalnym optimum.

Problem komiwojażera (Traveling Salesman Problem, TSP) to jedno z klasycznych zagadnień optymalizacyjnych, w którym należy znaleźć najkrótszą trasę przechodzącą przez wszystkie zadane punkty dokładnie raz i powracającą do punktu początkowego. W kontekście systemu komunikacji miejskiej problem ten nabiera dodatkowej złożoności:

\begin{itemize}
    \item Odległości między przystankami nie są stałe, ale zależą od aktualnych połączeń komunikacyjnych dostępnych w danym momencie.
    \item Czas przejazdu między przystankami zależy od rozkładu jazdy oraz ewentualnych przesiadek.
    \item Zamiast minimalizacji dystansu, optymalizujemy czas przejazdu lub liczbę przesiadek.
    \item Przestrzeń rozwiązań jest ogromna - dla $n$ przystanków liczba możliwych permutacji wynosi $(n-1)!/2$.
\end{itemize}

Metoda przeszukiwania z zabronieniami (Tabu Search) została zaproponowana przez Freda Glovera w 1986 roku i stanowi zaawansowaną technikę metaheurystyczną, która rozszerza klasyczne metody lokalnego przeszukiwania o struktury pamięciowe. Kluczowe elementy algorytmu Tabu Search to:

\begin{enumerate}
    \item \textbf{Lista tabu} - struktura pamięciowa przechowująca ostatnio wykonane ruchy, które są czasowo zabronione, by uniknąć cyklicznego przeszukiwania tych samych rozwiązań.
    \item \textbf{Mechanizm aspiracji} - pozwala na zaakceptowanie ruchu z listy tabu, jeśli prowadzi on do rozwiązania lepszego niż najlepsze dotychczas znalezione.
    \item \textbf{Intensyfikacja} - koncentracja przeszukiwania w obiecujących regionach przestrzeni rozwiązań.
    \item \textbf{Dywersyfikacja} - zachęcanie do eksploracji niezbadanych obszarów przestrzeni rozwiązań.
\end{enumerate}

W odróżnieniu od klasycznych algorytmów lokalnego przeszukiwania, Tabu Search może zaakceptować ruchy pogarszające obecne rozwiązanie, co umożliwia wydostanie się z lokalnych optimów. Jednocześnie, dzięki liście tabu, algorytm unika powrotu do rozwiązań już przeanalizowanych.

\subsubsection{Podstawowa implementacja}
Implementacja algorytmu przeszukiwania z zabronieniami dla problemu odwiedzenia zbioru przystanków obejmuje kilka kluczowych elementów. Poniżej przedstawiono szczegółowy opis implementacji:

\paragraph{Funkcja kosztu}
Funkcja \texttt{calculate\_route\_cost} ocenia jakość danego rozwiązania poprzez obliczenie całkowitego kosztu trasy. W zależności od wybranego kryterium optymalizacji, funkcja oblicza:
\begin{itemize}
    \item Całkowity czas podróży - suma czasów przejazdów między kolejnymi przystankami oraz czasów oczekiwania na połączenia.
    \item Całkowitą liczbę przesiadek - suma wszystkich zmian linii komunikacyjnych wymaganych na trasie.
\end{itemize}

Działanie funkcji kosztu można przedstawić następująco:

\begin{algorithmic}[1]
\Procedure{ObliczKosztTrasy}{$stacjaPoczątkowa, sekwencjaStacji, kryterium, czasStartu, graf$}
    \State Inicjalizuj pustą ścieżkę i ustaw bieżącą stację na stację początkową
    \For{każda następna stacja w sekwencji}
        \State Znajdź optymalną trasę z bieżącej stacji do następnej stacji
        \If{nie znaleziono trasy}
            \Return trasa niemożliwa
        \EndIf
        \State Zaktualizuj czas bieżący i bieżącą stację
        \State Dodaj znalezioną trasę do pełnej ścieżki
        \If{kryterium to liczba przesiadek}
            \State Zlicz liczbę przesiadek na tym odcinku
        \EndIf
    \EndFor
    
    \State Znajdź trasę powrotną do stacji początkowej
    \If{nie znaleziono trasy powrotnej}
        \Return trasa niemożliwa
    \EndIf
    
    \State Oblicz całkowity koszt w zależności od kryterium optymalizacji
    \Return koszt, pełna ścieżka, trasa możliwa
\EndProcedure
\end{algorithmic}

\paragraph{Generowanie sąsiedztwa}
W każdej iteracji algorytmu generujemy zbiór sąsiednich rozwiązań poprzez stosowanie dwóch typów ruchów:
\begin{itemize}
    \item \textbf{Zamiana (swap)} - wymiana pozycji dwóch losowo wybranych przystanków w sekwencji.
    \item \textbf{Wstawienie (insert)} - wyjęcie przystanku z jednej pozycji i wstawienie go na inną pozycję w sekwencji.
\end{itemize}

\begin{algorithmic}[1]
\Procedure{GenerujSąsiada}{$bieżącaSekwencja$}
    \State Wybierz losowo rodzaj ruchu: "zamiana" lub "wstawienie"
    \If{wybrany ruch to "zamiana"}
        \State Wybierz losowo dwie pozycje i zamień elementy miejscami
    \Else
        \State Wybierz losowo pozycję elementu do usunięcia i miejsce wstawienia
        \State Przenieś element z pierwszej pozycji na drugą
    \EndIf
    \State \Return nowa sekwencja, informacja o wykonanym ruchu
\EndProcedure
\end{algorithmic}

\paragraph{Główny algorytm Tabu Search}
Poniżej przedstawiony jest uproszczony pseudokod głównego algorytmu Tabu Search:

\begin{algorithmic}[1]
\Procedure{TabuSearch}{$stacjaPoczątkowa, stacjeDoOdwiedzenia, kryterium, czasStartu$}
    \If{brak stacji do odwiedzenia}
        \Return rozwiązanie trywialne
    \EndIf

    \State Wygeneruj losowe rozwiązanie początkowe (permutację stacji)
    \State Oceń koszt rozwiązania początkowego
    \State Zainicjalizuj najlepsze rozwiązanie jako bieżące
    \State Utwórz pustą listę tabu
    
    \For{określona liczba iteracji}
        \State Generuj i oceniaj sąsiedztwo bieżącego rozwiązania:
        \State $\quad$ - Pomiń ruchy znajdujące się na liście tabu, chyba że spełniają kryterium aspiracji
        \State $\quad$ - Wybierz najlepszego sąsiada

        \If{nie znaleziono ważnego sąsiada}
            \State Wykonaj restart z losowego rozwiązania
        \Else
            \State Przenieś się do najlepszego znalezionego sąsiada
            \State Dodaj wykonany ruch do listy tabu
            \State Usuń najstarsze elementy z listy tabu, jeśli przekroczyła maksymalny rozmiar
            
            \If{bieżące rozwiązanie lepsze od najlepszego znanego}
                \State Zaktualizuj najlepsze rozwiązanie
            \EndIf
        \EndIf
    \EndFor
    
    \Return najlepsze znalezione rozwiązanie
\EndProcedure
\end{algorithmic}

Przedstawiona implementacja Tabu Search posiada kilka kluczowych cech:

\begin{enumerate}
    \item \textbf{Pamięć krótkoterminowa} - lista tabu przechowująca niedawno wykonane ruchy, zapobiegająca zawracaniu do niedawno odwiedzonych stanów.
    
    \item \textbf{Kryterium aspiracji} - możliwość akceptowania ruchów z listy tabu, jeśli prowadzą do rozwiązania lepszego niż najlepsze znane.
    
    \item \textbf{Eksploracja} - algorytm może akceptować rozwiązania gorsze od bieżącego, co pomaga w wydostaniu się z lokalnych minimów.
    
    \item \textbf{Strategia dywersyfikacji} - losowe restarty, gdy algorytm nie może znaleźć ważnych sąsiadów.
\end{enumerate}

Warto podkreślić, że w kontekście sieci komunikacji miejskiej obliczanie kosztu trasy jest złożoną operacją, która wymaga wyszukiwania optymalnych połączeń między kolejnymi przystankami przy uwzględnieniu czasów odjazdów, przyjazdów i ewentualnych przesiadek. Funkcja oceny rozwiązania wykorzystuje wcześniej zaimplementowany algorytm A* do znajdowania optymalnych połączeń między kolejnymi przystankami w sekwencji.

Dzięki zastosowaniu metaheurystyki Tabu Search możliwe jest efektywne przeszukiwanie ogromnej przestrzeni rozwiązań i znajdowanie wysokiej jakości tras w rozsądnym czasie, co byłoby niemożliwe przy użyciu metod dokładnych dla większych instancji problemu.

\subsubsection{Wyniki i analiza}
Podstawowa wersja algorytmu Tabu Search została przetestowana na trzech scenariuszach o rosnącym poziomie złożoności. Celem było zbadanie skuteczności algorytmu dla problemu odwiedzenia zbioru przystanków i powrotu do punktu początkowego przy optymalizacji całkowitego czasu przejazdu.

\paragraph{Scenariusze testowe i metodologia}
Przeprowadzono następujące testy:
\begin{enumerate}
    \item \textbf{Scenariusz prosty}: Odwiedzenie jednego przystanku (Prudnicka) z powrotem do przystanku początkowego (Śliczna), z czasem startu 16:25.
    \item \textbf{Scenariusz średni}: Odwiedzenie dwóch przystanków (most Grunwaldzki, GALERIA DOMINIKAŃSKA) i powrót do przystanku Śliczna, z czasem startu 8:50.
    \item \textbf{Scenariusz złożony}: Odwiedzenie czterech przystanków (Bezpieczna, most Grunwaldzki, PL. GRUNWALDZKI, Ogród Botaniczny) i powrót do przystanku Śliczna, z czasem startu 16:25.
\end{enumerate}

W każdym teście algorytm wykonywał określoną liczbę iteracji (domyślnie 100, w przypadku scenariusza złożonego zwiększono do 200 ze względu na większą złożoność problemu). Wszystkie testy przeprowadzono z optymalizacją czasu przejazdu jako głównego kryterium.

\paragraph{Wyniki eksperymentów}
Poniższa tabela podsumowuje wyniki uzyskane dla trzech scenariuszy testowych:

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Scenariusz} & \textbf{Koszt [min]} & \textbf{Czas obliczeń [s]} & \textbf{Liczba odwiedzonych przystanków} \\
\hline
Prosty & 14 & 0,98 & 1 + początkowy \\
Średni & 40 & 14,52 & 2 + początkowy \\
Złożony & 76 & 258,55 & 4 + początkowy \\
\hline
\end{tabular}
\end{center}

\paragraph{Analiza szczegółowa trasy dla scenariusza prostego}
Dla prostego problemu odwiedzenia jednego przystanku (Prudnicka) i powrotu do przystanku początkowego (Śliczna), algorytm znalazł trasę o całkowitym czasie przejazdu 14 minut:

\begin{itemize}
    \item Trasa do przystanku Prudnicka:
    \begin{itemize}
        \item Linia 112: Śliczna → Borowska (Aquapark) (16:25--16:27)
        \item Linia 124: Borowska (Aquapark) → Kamienna (16:28--16:31)
        \item Linia 8: Kamienna → Prudnicka (16:31--16:32)
    \end{itemize}
    \item Trasa powrotna:
    \begin{itemize}
        \item Linia 18: Prudnicka → Bardzka (16:32--16:35)
        \item Linia 146: Bardzka → Śliczna (16:36--16:39)
    \end{itemize}
\end{itemize}

Czas obliczeń dla tego scenariusza wyniósł zaledwie 0,98 sekundy, co wskazuje na wysoką efektywność algorytmu dla prostych problemów.

\paragraph{Analiza szczegółowa trasy dla scenariusza średniego}
Dla średniego problemu odwiedzenia dwóch przystanków i powrotu, algorytm znalazł trasę o całkowitym czasie przejazdu 40 minut:

\begin{itemize}
    \item Trasa do przystanku most Grunwaldzki:
    \begin{itemize}
        \item Linia 612: Śliczna → DWORZEC AUTOBUSOWY (08:50--08:54)
        \item Linia K: DWORZEC AUTOBUSOWY → DWORZEC GŁÓWNY (08:54--08:57)
        \item Linia 4: DWORZEC GŁÓWNY → most Grunwaldzki (08:57--09:08)
    \end{itemize}
    \item Trasa do GALERIA DOMINIKAŃSKA:
    \begin{itemize}
        \item Linia 145: most Grunwaldzki → Poczta Główna (09:09--09:11)
        \item Linia N: Poczta Główna → GALERIA DOMINIKAŃSKA (09:12--09:15)
    \end{itemize}
    \item Trasa powrotna:
    \begin{itemize}
        \item Linia N: GALERIA DOMINIKAŃSKA → DWORZEC AUTOBUSOWY (09:15--09:22)
        \item Linia 113: DWORZEC AUTOBUSOWY → Śliczna (09:24--09:30)
    \end{itemize}
\end{itemize}

Czas obliczeń dla tego scenariusza wyniósł 14,52 sekundy, co stanowi około 15-krotny wzrost w porównaniu ze scenariuszem prostym.

\paragraph{Analiza szczegółowa trasy dla scenariusza złożonego}
Dla złożonego problemu odwiedzenia czterech przystanków, algorytm znalazł trasę o całkowitym czasie przejazdu 76 minut. Ze względu na złożoność trasy, przedstawiono ją w skróconej formie:

\begin{itemize}
    \item Śliczna → Bezpieczna (16:25--17:00) - z wykorzystaniem linii 112, 15 i K
    \item Bezpieczna → Ogród Botaniczny (17:00--17:18) - z wykorzystaniem linii K, 930 i 23 
    \item Ogród Botaniczny → PL. GRUNWALDZKI (17:18--17:23) - z wykorzystaniem linii 111
    \item PL. GRUNWALDZKI → most Grunwaldzki (17:23--17:24) - z wykorzystaniem linii 13
    \item most Grunwaldzki → Śliczna (17:24--17:41) - z wykorzystaniem linii 13, 16, 134 i 112
\end{itemize}

Czas obliczeń dla tego scenariusza wyniósł 258,55 sekundy (ponad 4 minuty), co pokazuje znaczący wzrost złożoności obliczeniowej wraz ze zwiększeniem liczby przystanków do odwiedzenia.

\paragraph{Analiza skalowania algorytmu}
Na podstawie przeprowadzonych testów można zauważyć, że czas obliczeń algorytmu Tabu Search rośnie wykładniczo wraz ze wzrostem liczby przystanków do odwiedzenia:

\begin{itemize}
    \item Dla 1 przystanku: 0,98 sekundy
    \item Dla 2 przystanków: 14,52 sekundy (około 15-krotny wzrost)
    \item Dla 4 przystanków: 258,55 sekundy (około 18-krotny wzrost względem scenariusza średniego)
\end{itemize}

Ten wykładniczy wzrost czasu obliczeń jest zgodny z teoretyczną złożonością problemu komiwojażera, gdzie liczba możliwych permutacji stacji rośnie jako $(n-1)!/2$ dla $n$ przystanków.

\paragraph{Wnioski}
Podstawowa implementacja algorytmu Tabu Search skutecznie znajduje rozwiązania dla problemu odwiedzenia zbioru przystanków w systemie komunikacji miejskiej, jednak z pewnymi ograniczeniami:

\begin{enumerate}
    \item Algorytm jest wysoce efektywny dla małych instancji problemu (1-2 przystanki), z czasami obliczeń poniżej 15 sekund.
    \item Dla większych instancji (4 przystanki) czas obliczeń znacząco rośnie, osiągając ponad 4 minuty, co może być problematyczne dla aplikacji działających w czasie rzeczywistym.
    \item Jakość znalezionych rozwiązań wydaje się być dobra, z logicznymi sekwencjami przystanków i efektywnym wykorzystaniem dostępnych połączeń.
    \item Zauważalna jest tendencja algorytmu do preferowania przystanków położonych w podobnych rejonach miasta, co sugeruje, że algorytm skutecznie wykorzystuje strukturę geograficzną sieci komunikacyjnej.
\end{enumerate}

Wyniki wskazują na potrzebę dalszych modyfikacji algorytmu w celu poprawy jego efektywności dla większych instancji problemu. W kolejnych sekcjach zbadamy wpływ modyfikacji takich jak adaptacyjna długość listy tabu, kryterium aspiracji oraz strategie próbkowania sąsiedztwa na wydajność algorytmu.

\subsection{Modyfikacja długości listy tabu}
\subsubsection{Opis teoretyczny}
Długość listy tabu ma istotny wpływ na efektywność algorytmu. Zbyt krótka lista może prowadzić do cyklicznego przeszukiwania tych samych rozwiązań, natomiast zbyt długa może nadmiernie ograniczać przestrzeń poszukiwań.

\subsubsection{Implementacja}
% Opis implementacji adaptacyjnego doboru długości listy tabu

\subsubsection{Wyniki i analiza}
% Porównanie z wersją podstawową

\subsection{Modyfikacja z kryterium aspiracji}
\subsubsection{Opis teoretyczny}
Kryterium aspiracji pozwala na przyjęcie rozwiązania znajdującego się na liście tabu, jeśli spełnia ono określone warunki, np. jest lepsze od najlepszego dotychczas znalezionego rozwiązania.

\subsubsection{Implementacja}
% Opis implementacji kryterium aspiracji

\subsubsection{Wyniki i analiza}
% Porównanie z poprzednimi wersjami algorytmu

\subsection{Strategia próbkowania sąsiedztwa}
\subsubsection{Opis teoretyczny}
Efektywne próbkowanie sąsiedztwa bieżącego rozwiązania może znacząco wpłynąć na wydajność algorytmu, szczególnie dla dużych instancji problemu.

\subsubsection{Implementacja}
% Opis implementacji strategii próbkowania sąsiedztwa

\subsubsection{Wyniki i analiza}
% Porównanie z poprzednimi wersjami algorytmu

\section{Podsumowanie}
\subsection{Porównanie zaimplementowanych algorytmów}
% Porównanie wszystkich zaimplementowanych algorytmów pod kątem jakości rozwiązań i czasu obliczeń

\subsection{Napotkane problemy implementacyjne}
% Opis problemów napotkanych podczas implementacji oraz sposobów ich rozwiązania

\subsection{Wnioski}
% Ogólne wnioski dotyczące efektywności algorytmów w kontekście planowania tras w komunikacji miejskiej

\section{Wykorzystane biblioteki}
% Opis bibliotek wykorzystanych do implementacji algorytmów

\begin{thebibliography}{9}
    \bibitem{dijkstra} Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.
    \bibitem{astar} Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). A formal basis for the heuristic determination of minimum cost paths. IEEE Transactions on Systems Science and Cybernetics, 4(2), 100-107.
    \bibitem{tabu} Glover, F. (1989). Tabu search—part I. ORSA Journal on Computing, 1(3), 190-206.
    \bibitem{tsp} Lawler, E. L., Lenstra, J. K., Rinnooy Kan, A. H. G., & Shmoys, D. B. (1985). The Traveling Salesman Problem: A Guided Tour of Combinatorial Optimization. Wiley.
\end{thebibliography}

\appendix
\section{Kod źródłowy}
% Fragmenty kodu źródłowego ilustrujące kluczowe elementy implementacji

\section{Przykładowe dane wejściowe i wyjściowe}
% Przykłady danych wejściowych i odpowiadających im wyników

\end{document}
